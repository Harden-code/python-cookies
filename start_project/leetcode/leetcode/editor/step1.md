1. 时间复杂度由来
原因:
 - 避免代码依赖于机器,测试数据或者测试环境
 - 避免写测试代码
好处:
 - 不依赖机器,测试数据等测试环境
 - 不需要写测试代码

2. 大o时间复杂度表示法
- 只表示数据规模n很大时候的执行效率
- 忽略低阶,常理,系数,只保留最高量级
- 表示执行时间随着数据规模的增长趋势,而不是具体的执行时间
> 找代码执行次数最多的

3. 常见时间复杂度量级
- O(1) 哈希表
- O(log n) 二分查找 平衡二插入树 跳表
- O(n) 数组,链表遍历
- O(n log n) 快速排序 归并排序 堆排序
- O(n^2) 冒泡 插入 选择排序
- O(2^n) 回溯穷举 
- O(n!) 全排序 n^n

4. 最好,最坏,平均时间复杂度
5. 均摊时间复杂度和摊还分析(平均时间复杂度)
摊还分析:把耗时操作分为耗时少的操作上

对某个数据结构进行一组连续操作,大部分情况下时间复杂度都很低
只有在个别情况下时间复杂度比较高,而且这些操作之间存在前后连
贯的时序关系,这时就可以将一组操作放在一块分析,看是否能将耗时
多的操作均摊到其他耗时少的操作上

利用摊还分析法得到的平均时间复杂度,叫做均摊时间复杂度,实际
上均摊时间复杂度就是一种特殊的平均时间复杂度.能用该方法的代码不多
常见的就是支持动态扩容的数据结构

``` python 
class Demo:
    def __init__(self,i,size):
        self.i=i
        self.size
        self.arr=array.array()
        
    def insert(self,data):
        if self.i == self.size:
            self.size*=2
            self.arr=array.array()
        self.arr[i++]=data
``` 
6. 空间复杂度
时间复杂度是累计值
空间复杂度是峰值

纯编程题
实现繁琐,边界条件复杂,要考虑的特殊情况比较多,容易写出bug
1. 先忽略掉不容易处理的特殊情况,只考虑正常情况,简化编程
2. 写代码前先写注射,通过注射让代码模块化
3. 写完代码多举例来验证

找规律题
举例总结出规律

